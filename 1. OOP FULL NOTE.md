# Complete Object-Oriented Programming Guide
## Universal Concepts with Vehicle Management System Example

## Table of Contents
1. [OOP Fundamentals](#oop-fundamentals)
2. [Core Principles](#core-principles)
3. [Universal Example: Vehicle Management System](#universal-example)
4. [Abstract Classes vs Interfaces vs Traits](#abstract-vs-interface-vs-traits)
5. [Advanced Concepts](#advanced-concepts)
6. [Language-Specific Implementations](#language-implementations)
7. [Interview Questions & Answers](#interview-questions)
8. [Best Practices](#best-practices)

---

## OOP Fundamentals

Object-Oriented Programming is a programming paradigm based on the concept of "objects" that contain:
- **Data** (attributes/properties/fields)
- **Code** (methods/functions/behaviors)

### The Four Pillars of OOP

1. **Encapsulation** - Bundling data and methods together, hiding internal details
2. **Inheritance** - Creating new classes based on existing ones
3. **Polymorphism** - Using one interface for different underlying data types
4. **Abstraction** - Hiding complex implementation details, showing only essential features

---

## Universal Example: Vehicle Management System

We'll build a complete vehicle management system that demonstrates every OOP concept:

### 1. ENCAPSULATION - Data Hiding and Access Control

```java
// Java Example
public class Vehicle {
    // Private fields (encapsulated data)
    private String brand;
    private String model;
    private int year;
    private double price;
    private boolean isRunning;
    
    // Constructor
    public Vehicle(String brand, String model, int year, double price) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        setPrice(price); // Using setter for validation
        this.isRunning = false;
    }
    
    // Public getters (controlled access)
    public String getBrand() { return brand; }
    public String getModel() { return model; }
    public int getYear() { return year; }
    public double getPrice() { return price; }
    public boolean isRunning() { return isRunning; }
    
    // Public setters with validation (controlled modification)
    public void setPrice(double price) {
        if (price >= 0) {
            this.price = price;
        } else {
            throw new IllegalArgumentException("Price cannot be negative");
        }
    }
    
    // Public methods (controlled behavior)
    public void start() {
        if (!isRunning) {
            isRunning = true;
            System.out.println(brand + " " + model + " started");
        }
    }
    
    public void stop() {
        if (isRunning) {
            isRunning = false;
            System.out.println(brand + " " + model + " stopped");
        }
    }
    
    // Protected method (accessible to subclasses)
    protected void performMaintenance() {
        System.out.println("Performing basic maintenance on " + brand + " " + model);
    }
}
```

```php
// PHP Example
class Vehicle {
    private string $brand;
    private string $model;
    private int $year;
    private float $price;
    private bool $isRunning;
    
    public function __construct(string $brand, string $model, int $year, float $price) {
        $this->brand = $brand;
        $this->model = $model;
        $this->year = $year;
        $this->setPrice($price);
        $this->isRunning = false;
    }
    
    // Getters
    public function getBrand(): string { return $this->brand; }
    public function getModel(): string { return $this->model; }
    public function getYear(): int { return $this->year; }
    public function getPrice(): float { return $this->price; }
    public function isRunning(): bool { return $this->isRunning; }
    
    // Setter with validation
    public function setPrice(float $price): void {
        if ($price >= 0) {
            $this->price = $price;
        } else {
            throw new InvalidArgumentException("Price cannot be negative");
        }
    }
    
    public function start(): void {
        if (!$this->isRunning) {
            $this->isRunning = true;
            echo "{$this->brand} {$this->model} started\n";
        }
    }
    
    public function stop(): void {
        if ($this->isRunning) {
            $this->isRunning = false;
            echo "{$this->brand} {$this->model} stopped\n";
        }
    }
    
    protected function performMaintenance(): void {
        echo "Performing basic maintenance on {$this->brand} {$this->model}\n";
    }
}
```

**Key Points about Encapsulation:**
- **Private fields** prevent direct access from outside the class
- **Public methods** provide controlled access to private data
- **Validation** can be enforced in setters
- **Data integrity** is maintained through controlled access

---

### 2. INTERFACES - Contracts for Implementation

```java
// Java Interface
interface Drivable {
    void accelerate(double speed);
    void brake();
    double getCurrentSpeed();
    String getTransmissionType();
}

interface Flyable {
    void takeOff();
    void land();
    double getAltitude();
    boolean isAirborne();
}

interface Maintainable {
    void scheduleMaintenance();
    boolean needsMaintenance();
    double getMaintenanceCost();
}

interface ElectricPowered {
    void charge(double hours);
    double getBatteryLevel();
    double getRange();
}

interface FuelPowered {
    void refuel(double liters);
    double getFuelLevel();
    double getMileage();
}
```

```php
// PHP Interface
interface Drivable {
    public function accelerate(float $speed): void;
    public function brake(): void;
    public function getCurrentSpeed(): float;
    public function getTransmissionType(): string;
}

interface Flyable {
    public function takeOff(): void;
    public function land(): void;
    public function getAltitude(): float;
    public function isAirborne(): bool;
}

interface Maintainable {
    public function scheduleMaintenance(): void;
    public function needsMaintenance(): bool;
    public function getMaintenanceCost(): float;
}

trait ElectricPowerTrait {
    private float $batteryLevel = 100.0;
    private float $maxRange = 500.0;
    
    public function charge(float $hours): void {
        $this->batteryLevel = min(100.0, $this->batteryLevel + ($hours * 10));
        echo "Charged for {$hours} hours. Battery: {$this->batteryLevel}%\n";
    }
    
    public function getBatteryLevel(): float {
        return $this->batteryLevel;
    }
    
    public function getRange(): float {
        return ($this->batteryLevel / 100) * $this->maxRange;
    }
}

trait FuelPowerTrait {
    private float $fuelLevel = 100.0;
    private float $tankCapacity = 60.0;
    private float $mileage = 15.0; // km per liter
    
    public function refuel(float $liters): void {
        $this->fuelLevel = min($this->tankCapacity, $this->fuelLevel + $liters);
        echo "Refueled with {$liters} liters. Tank: {$this->fuelLevel}L\n";
    }
    
    public function getFuelLevel(): float {
        return $this->fuelLevel;
    }
    
    public function getMileage(): float {
        return $this->mileage;
    }
}
```

**Key Points about Interfaces:**
- **Contract definition** - what methods must be implemented
- **Multiple inheritance** - a class can implement multiple interfaces
- **No implementation** - only method signatures (in most languages)
- **Polymorphism enabler** - allows treating different objects uniformly

---

### 3. ABSTRACT CLASSES - Partial Implementation with Enforced Structure

```java
// Java Abstract Class
abstract class AbstractVehicle implements Drivable, Maintainable {
    protected String brand;
    protected String model;
    protected int year;
    protected double currentSpeed;
    protected boolean isRunning;
    protected int mileage;
    protected String transmissionType;
    
    // Constructor
    public AbstractVehicle(String brand, String model, int year, String transmissionType) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.transmissionType = transmissionType;
        this.currentSpeed = 0;
        this.isRunning = false;
        this.mileage = 0;
    }
    
    // Concrete methods (common implementation)
    public void start() {
        if (!isRunning) {
            isRunning = true;
            System.out.println(brand + " " + model + " engine started");
        }
    }
    
    public void stop() {
        if (isRunning) {
            isRunning = false;
            currentSpeed = 0;
            System.out.println(brand + " " + model + " engine stopped");
        }
    }
    
    public double getCurrentSpeed() {
        return currentSpeed;
    }
    
    public String getTransmissionType() {
        return transmissionType;
    }
    
    // Abstract methods (must be implemented by subclasses)
    public abstract void accelerate(double speed);
    public abstract void brake();
    public abstract double getMaxSpeed();
    public abstract String getVehicleType();
    
    // Maintenance methods with default implementation
    public boolean needsMaintenance() {
        return mileage > 10000;
    }
    
    public void scheduleMaintenance() {
        System.out.println("Maintenance scheduled for " + brand + " " + model);
        mileage = 0; // Reset after maintenance
    }
    
    public double getMaintenanceCost() {
        return year < 2020 ? 500.0 : 300.0;
    }
    
    // Template method pattern
    public final void performTrip(double distance) {
        start();
        accelerate(60);
        System.out.println("Traveling " + distance + " km");
        brake();
        stop();
        mileage += (int)distance;
    }
}
```

```php
// PHP Abstract Class
abstract class AbstractVehicle implements Drivable, Maintainable {
    protected string $brand;
    protected string $model;
    protected int $year;
    protected float $currentSpeed;
    protected bool $isRunning;
    protected int $mileage;
    protected string $transmissionType;
    
    public function __construct(string $brand, string $model, int $year, string $transmissionType) {
        $this->brand = $brand;
        $this->model = $model;
        $this->year = $year;
        $this->transmissionType = $transmissionType;
        $this->currentSpeed = 0;
        $this->isRunning = false;
        $this->mileage = 0;
    }
    
    public function start(): void {
        if (!$this->isRunning) {
            $this->isRunning = true;
            echo "{$this->brand} {$this->model} engine started\n";
        }
    }
    
    public function stop(): void {
        if ($this->isRunning) {
            $this->isRunning = false;
            $this->currentSpeed = 0;
            echo "{$this->brand} {$this->model} engine stopped\n";
        }
    }
    
    public function getCurrentSpeed(): float {
        return $this->currentSpeed;
    }
    
    public function getTransmissionType(): string {
        return $this->transmissionType;
    }
    
    // Abstract methods
    abstract public function accelerate(float $speed): void;
    abstract public function brake(): void;
    abstract public function getMaxSpeed(): float;
    abstract public function getVehicleType(): string;
    
    // Default maintenance implementation
    public function needsMaintenance(): bool {
        return $this->mileage > 10000;
    }
    
    public function scheduleMaintenance(): void {
        echo "Maintenance scheduled for {$this->brand} {$this->model}\n";
        $this->mileage = 0;
    }
    
    public function getMaintenanceCost(): float {
        return $this->year < 2020 ? 500.0 : 300.0;
    }
    
    // Template method
    final public function performTrip(float $distance): void {
        $this->start();
        $this->accelerate(60);
        echo "Traveling {$distance} km\n";
        $this->brake();
        $this->stop();
        $this->mileage += (int)$distance;
    }
}
```

**Key Points about Abstract Classes:**
- **Partial implementation** - can have both concrete and abstract methods
- **Cannot be instantiated** - must be inherited
- **Enforces structure** - subclasses must implement abstract methods
- **Code reuse** - provides common functionality to subclasses
- **Template method pattern** - defines algorithm structure

---

### 4. INHERITANCE & POLYMORPHISM - Complete Implementation

```java
// Car implementation
class Car extends AbstractVehicle implements FuelPowered {
    private double fuelLevel;
    private double tankCapacity;
    private double mileagePerLiter;
    
    public Car(String brand, String model, int year, String transmissionType) {
        super(brand, model, year, transmissionType);
        this.fuelLevel = 50.0;
        this.tankCapacity = 60.0;
        this.mileagePerLiter = 15.0;
    }
    
    @Override
    public void accelerate(double speed) {
        if (isRunning && fuelLevel > 0) {
            currentSpeed = Math.min(speed, getMaxSpeed());
            fuelLevel -= 0.1; // Consume fuel
            System.out.println("Car accelerating to " + currentSpeed + " km/h");
        }
    }
    
    @Override
    public void brake() {
        currentSpeed = Math.max(0, currentSpeed - 20);
        System.out.println("Car braking, speed: " + currentSpeed + " km/h");
    }
    
    @Override
    public double getMaxSpeed() {
        return 180.0;
    }
    
    @Override
    public String getVehicleType() {
        return "Car";
    }
    
    // FuelPowered interface implementation
    public void refuel(double liters) {
        fuelLevel = Math.min(tankCapacity, fuelLevel + liters);
        System.out.println("Refueled. Current level: " + fuelLevel + "L");
    }
    
    public double getFuelLevel() {
        return fuelLevel;
    }
    
    public double getMileage() {
        return mileagePerLiter;
    }
}

// Electric Car implementation
class ElectricCar extends AbstractVehicle implements ElectricPowered {
    private double batteryLevel;
    private double maxRange;
    
    public ElectricCar(String brand, String model, int year) {
        super(brand, model, year, "Automatic");
        this.batteryLevel = 100.0;
        this.maxRange = 500.0;
    }
    
    @Override
    public void accelerate(double speed) {
        if (isRunning && batteryLevel > 0) {
            currentSpeed = Math.min(speed, getMaxSpeed());
            batteryLevel -= 0.05; // Consume battery
            System.out.println("Electric car accelerating to " + currentSpeed + " km/h");
        }
    }
    
    @Override
    public void brake() {
        currentSpeed = Math.max(0, currentSpeed - 25);
        batteryLevel += 0.01; // Regenerative braking
        System.out.println("Electric car braking with regeneration, speed: " + currentSpeed + " km/h");
    }
    
    @Override
    public double getMaxSpeed() {
        return 200.0;
    }
    
    @Override
    public String getVehicleType() {
        return "Electric Car";
    }
    
    // ElectricPowered interface implementation
    public void charge(double hours) {
        batteryLevel = Math.min(100.0, batteryLevel + (hours * 10));
        System.out.println("Charged for " + hours + " hours. Battery: " + batteryLevel + "%");
    }
    
    public double getBatteryLevel() {
        return batteryLevel;
    }
    
    public double getRange() {
        return (batteryLevel / 100) * maxRange;
    }
}

// Airplane implementation
class Airplane extends AbstractVehicle implements Flyable, FuelPowered {
    private double altitude;
    private boolean isAirborne;
    private double fuelLevel;
    private double tankCapacity;
    
    public Airplane(String brand, String model, int year) {
        super(brand, model, year, "Turbine");
        this.altitude = 0;
        this.isAirborne = false;
        this.fuelLevel = 1000.0;
        this.tankCapacity = 2000.0;
    }
    
    @Override
    public void accelerate(double speed) {
        if (isRunning && fuelLevel > 0) {
            currentSpeed = Math.min(speed, getMaxSpeed());
            fuelLevel -= 2.0; // Higher fuel consumption
            System.out.println("Airplane accelerating to " + currentSpeed + " km/h");
        }
    }
    
    @Override
    public void brake() {
        if (!isAirborne) {
            currentSpeed = Math.max(0, currentSpeed - 30);
            System.out.println("Airplane braking, speed: " + currentSpeed + " km/h");
        }
    }
    
    @Override
    public double getMaxSpeed() {
        return 900.0;
    }
    
    @Override
    public String getVehicleType() {
        return "Airplane";
    }
    
    // Flyable interface implementation
    public void takeOff() {
        if (isRunning && currentSpeed > 250 && !isAirborne) {
            isAirborne = true;
            altitude = 1000;
            System.out.println("Airplane taking off, altitude: " + altitude + "m");
        }
    }
    
    public void land() {
        if (isAirborne) {
            isAirborne = false;
            altitude = 0;
            currentSpeed = 200;
            System.out.println("Airplane landing");
        }
    }
    
    public double getAltitude() {
        return altitude;
    }
    
    public boolean isAirborne() {
        return isAirborne;
    }
    
    // FuelPowered interface implementation
    public void refuel(double liters) {
        fuelLevel = Math.min(tankCapacity, fuelLevel + liters);
        System.out.println("Airplane refueled. Current level: " + fuelLevel + "L");
    }
    
    public double getFuelLevel() {
        return fuelLevel;
    }
    
    public double getMileage() {
        return 2.0; // km per liter (much lower for airplanes)
    }
}
```

```php
// PHP Implementation with Traits
class Car extends AbstractVehicle {
    use FuelPowerTrait;
    
    public function __construct(string $brand, string $model, int $year, string $transmissionType = "Manual") {
        parent::__construct($brand, $model, $year, $transmissionType);
    }
    
    public function accelerate(float $speed): void {
        if ($this->isRunning && $this->fuelLevel > 0) {
            $this->currentSpeed = min($speed, $this->getMaxSpeed());
            $this->fuelLevel -= 0.1;
            echo "Car accelerating to {$this->currentSpeed} km/h\n";
        }
    }
    
    public function brake(): void {
        $this->currentSpeed = max(0, $this->currentSpeed - 20);
        echo "Car braking, speed: {$this->currentSpeed} km/h\n";
    }
    
    public function getMaxSpeed(): float {
        return 180.0;
    }
    
    public function getVehicleType(): string {
        return "Car";
    }
}

class ElectricCar extends AbstractVehicle {
    use ElectricPowerTrait;
    
    public function __construct(string $brand, string $model, int $year) {
        parent::__construct($brand, $model, $year, "Automatic");
    }
    
    public function accelerate(float $speed): void {
        if ($this->isRunning && $this->batteryLevel > 0) {
            $this->currentSpeed = min($speed, $this->getMaxSpeed());
            $this->batteryLevel -= 0.05;
            echo "Electric car accelerating to {$this->currentSpeed} km/h\n";
        }
    }
    
    public function brake(): void {
        $this->currentSpeed = max(0, $this->currentSpeed - 25);
        $this->batteryLevel += 0.01; // Regenerative braking
        echo "Electric car braking with regeneration, speed: {$this->currentSpeed} km/h\n";
    }
    
    public function getMaxSpeed(): float {
        return 200.0;
    }
    
    public function getVehicleType(): string {
        return "Electric Car";
    }
}
```

---

### 5. POLYMORPHISM DEMONSTRATION

```java
// Polymorphism in action
public class VehicleManagementSystem {
    public static void main(String[] args) {
        // Polymorphic array - different types treated uniformly
        AbstractVehicle[] vehicles = {
            new Car("Toyota", "Camry", 2022, "Automatic"),
            new ElectricCar("Tesla", "Model 3", 2023),
            new Airplane("Boeing", "737", 2021)
        };
        
        // Runtime polymorphism - correct method called based on actual object type
        for (AbstractVehicle vehicle : vehicles) {
            System.out.println("\n=== " + vehicle.getVehicleType() + " Demo ===");
            
            // Polymorphic method calls
            vehicle.start();
            vehicle.accelerate(100);
            vehicle.brake();
            
            // Interface-based polymorphism
            if (vehicle instanceof Flyable) {
                Flyable flyable = (Flyable) vehicle;
                flyable.takeOff();
                System.out.println("Altitude: " + flyable.getAltitude());
                flyable.land();
            }
            
            if (vehicle instanceof FuelPowered) {
                FuelPowered fuelVehicle = (FuelPowered) vehicle;
                fuelVehicle.refuel(20);
                System.out.println("Fuel level: " + fuelVehicle.getFuelLevel());
            }
            
            if (vehicle instanceof ElectricPowered) {
                ElectricPowered electricVehicle = (ElectricPowered) vehicle;
                electricVehicle.charge(2);
                System.out.println("Battery level: " + electricVehicle.getBatteryLevel());
            }
            
            // Template method usage
            vehicle.performTrip(150);
            
            vehicle.stop();
        }
        
        // Method overloading demonstration
        VehicleService service = new VehicleService();
        service.processVehicle(vehicles[0]); // Car
        service.processVehicle((Car) vehicles[0]); // Specific Car processing
        service.processVehicle(vehicles[1], true); // Electric car with eco mode
    }
}

// Method overloading example
class VehicleService {
    public void processVehicle(AbstractVehicle vehicle) {
        System.out.println("Processing vehicle: " + vehicle.getVehicleType());
        vehicle.scheduleMaintenance();
    }
    
    public void processVehicle(Car car) {
        System.out.println("Processing car with special car services");
        car.refuel(30);
        processVehicle((AbstractVehicle) car);
    }
    
    public void processVehicle(AbstractVehicle vehicle, boolean ecoMode) {
        System.out.println("Processing vehicle in eco mode: " + ecoMode);
        if (vehicle instanceof ElectricPowered && ecoMode) {
            System.out.println("Enabling eco charging mode");
        }
        processVehicle(vehicle);
    }
}
```

---

## Abstract Classes vs Interfaces vs Traits - Complete Comparison

| Feature | Abstract Class | Interface | Trait (PHP/Scala) |
|---------|---------------|-----------|-------------------|
| **Purpose** | Partial implementation with enforced structure | Contract definition | Code reuse without inheritance |
| **Instantiation** | Cannot be instantiated | Cannot be instantiated | Cannot be instantiated |
| **Methods** | Concrete + Abstract methods | Only abstract methods (traditionally) | Concrete methods |
| **Fields/Properties** | Can have instance variables | Only constants | Can have properties |
| **Inheritance** | Single inheritance | Multiple implementation | Multiple use |
| **Access Modifiers** | All types (public, private, protected) | Public only | All types |
| **Constructor** | Can have constructors | Cannot have constructors | Can have constructors (PHP) |
| **When to Use** | When you need shared code and want to enforce structure | When you need a contract for unrelated classes | When you need to share code across unrelated classes |

### When to Use Each:

#### **Use Abstract Classes When:**
```java
// You have related classes that share common code
abstract class DatabaseConnection {
    protected String connectionString;
    protected boolean isConnected;
    
    // Common implementation
    public void connect() {
        isConnected = true;
        System.out.println("Connected to database");
    }
    
    // Force subclasses to implement
    public abstract void executeQuery(String query);
    public abstract String getConnectionType();
}

class MySQLConnection extends DatabaseConnection {
    public void executeQuery(String query) {
        System.out.println("Executing MySQL query: " + query);
    }
    
    public String getConnectionType() {
        return "MySQL";
    }
}
```

#### **Use Interfaces When:**
```java
// You need a contract for unrelated classes
interface Serializable {
    String serialize();
    void deserialize(String data);
}

// Completely different classes can implement the same interface
class User implements Serializable {
    public String serialize() { return "User data as JSON"; }
    public void deserialize(String data) { /* parse JSON */ }
}

class Configuration implements Serializable {
    public String serialize() { return "Config data as XML"; }
    public void deserialize(String data) { /* parse XML */ }
}
```

#### **Use Traits When:** (PHP example)
```php
// You need to share code across unrelated classes without inheritance
trait TimestampTrait {
    private DateTime $createdAt;
    private DateTime $updatedAt;
    
    public function setTimestamps(): void {
        $this->createdAt = new DateTime();
        $this->updatedAt = new DateTime();
    }
    
    public function touch(): void {
        $this->updatedAt = new DateTime();
    }
}

class User {
    use TimestampTrait;
    // User-specific code
}

class Product {
    use TimestampTrait;
    // Product-specific code
}
```

---

## Advanced OOP Concepts

### 1. **Composition vs Inheritance**

```java
// Inheritance (IS-A relationship)
class ElectricCar extends Car {
    // ElectricCar IS-A Car
}

// Composition (HAS-A relationship) - Often better
class Vehicle {
    private Engine engine;
    private Transmission transmission;
    private FuelSystem fuelSystem;
    
    public Vehicle(Engine engine, Transmission transmission, FuelSystem fuelSystem) {
        this.engine = engine;
        this.transmission = transmission;
        this.fuelSystem = fuelSystem;
    }
    
    public void start() {
        engine.start();
    }
    
    public void accelerate(double speed) {
        transmission.changeGear();
        engine.increaseRPM();
    }
}

class Engine {
    private String type;
    private int horsepower;
    
    public void start() {
        System.out.println("Engine started");
    }
    
    public void increaseRPM() {
        System.out.println("RPM increased");
    }
}
```

### 2. **Design Patterns in OOP**

#### **Factory Pattern:**
```java
interface VehicleFactory {
    AbstractVehicle createVehicle(String type, String brand, String model, int year);
}

class StandardVehicleFactory implements VehicleFactory {
    public AbstractVehicle createVehicle(String type, String brand, String model, int year) {
        switch (type.toLowerCase()) {
            case "car":
                return new Car(brand, model, year, "Manual");
            case "electric":
                return new ElectricCar(brand, model, year);
            case "airplane":
                return new Airplane(brand, model, year);
            default:
                throw new IllegalArgumentException("Unknown vehicle type: " + type);
        }
    }
}
```

#### **Observer Pattern:**
```java
interface VehicleObserver {
    void onSpeedChanged(AbstractVehicle vehicle, double newSpeed);
    void onFuelLevelChanged(AbstractVehicle vehicle, double newLevel);
}

class VehicleMonitoringSystem implements VehicleObserver {
    public void onSpeedChanged(AbstractVehicle vehicle, double newSpeed) {
        if (newSpeed > 120) {
            System.out.println("WARNING: " + vehicle.getVehicleType() + " exceeding speed limit!");
        }
    }
    
    public void onFuelLevelChanged(AbstractVehicle vehicle, double newLevel) {
        if (newLevel < 10) {
            System.out.println("WARNING: Low fuel in " + vehicle.getVehicleType());
        }
    }
}
```

#### **Strategy Pattern:**
```java
interface DrivingStrategy {
    void drive(AbstractVehicle vehicle);
}

class EconomyDriving implements DrivingStrategy {
    public void drive(AbstractVehicle vehicle) {
        vehicle.accelerate(60); // Moderate speed for fuel efficiency
    }
}

class SportDriving implements DrivingStrategy {
    public void drive(AbstractVehicle vehicle) {
        vehicle.accelerate(vehicle.getMaxSpeed() * 0.8); // High performance
    }
}

class AutonomousVehicle {
    private DrivingStrategy strategy;
    
    public void setDrivingStrategy(DrivingStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void engageAutoDrive(AbstractVehicle vehicle) {
        strategy.drive(vehicle);
    }
}
```

---

## Interview Questions & Answers

### **Q1: What's the difference between Abstract Class and Interface?**

**Answer:**
- **Abstract Class**: Provides partial implementation, can have concrete methods, instance variables, constructors. Used when classes share common code and structure. Single inheritance only.
- **Interface**: Defines a contract, traditionally only method signatures (no implementation), multiple inheritance supported. Used for unrelated classes that need same behavior.

**Example:** `AbstractVehicle` provides common vehicle functionality, while `Flyable` interface can be implemented by both `Airplane` and `Drone` (unrelated classes).

### **Q2: What is Polymorphism? Explain with examples.**

**Answer:**
Polymorphism allows objects of different types to be treated as instances of the same type through inheritance or interfaces. Two types:

1. **Runtime Polymorphism (Method Overriding):**
```java
AbstractVehicle[] vehicles = {new Car(), new Airplane()};
for (AbstractVehicle v : vehicles) {
    v.accelerate(100); // Calls appropriate implementation
}
```

2. **Compile-time Polymorphism (Method Overloading):**
```java
public void processVehicle(Car car) { }
public void processVehicle(Airplane plane) { }
public void processVehicle(AbstractVehicle vehicle, boolean ecoMode) { }
```

### **Q3: What is the Diamond Problem and how is it solved?**

**Answer:**
The Diamond Problem occurs in multiple inheritance when a class inherits from two classes that have a common base class, creating ambiguity.

```java
// Problem scenario (not allowed in Java/C#)
class A { void method() {} }
class B extends A { void method() {} }
class C extends A { void method() {} }
class D extends B, C { } // Which method() to inherit?
```

**Solutions:**
- **Java/C#**: Single inheritance + multiple interfaces
- **PHP Traits**: Explicit conflict resolution
- **C++**: Virtual inheritance

```php
// PHP solution with traits
trait TraitA {
    public function method() { echo "Trait A"; }
}

trait TraitB {
    public function method() { echo "Trait B"; }
}

class MyClass {
    use TraitA, TraitB {
        TraitA::method insteadof TraitB; // Resolve conflict
        TraitB::method as methodB;       // Alias
    }
}
```

### **Q4: Explain Encapsulation and its benefits.**

**Answer:**
Encapsulation bundles data and methods together while restricting direct access to internal components.

**Benefits:**
1. **Data Protection**: Private fields prevent unauthorized access
2. **Validation**: Setters can validate input
3. **Maintainability**: Internal changes don't affect external code
4. **Security**: Hide sensitive implementation details

```java
public class BankAccount {
    private double balance; // Encapsulated data
    
    public boolean withdraw(double amount) { // Controlled access
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false; // Invalid operation rejected
    }
}
```

### **Q5: What is Composition vs Inheritance? When to use each?**

**Answer:**
- **Inheritance**: "IS-A" relationship, child class inherits from parent
- **Composition**: "HAS-A" relationship, class contains other objects

**Use Inheritance when:**
- True "IS-A" relationship exists
- Need to override parent behavior
- Want to use polymorphism

**Use Composition when:**
- "HAS-A" relationship exists
- Need flexibility to change behavior at runtime
- Want to avoid tight coupling

```java
// Inheritance: ElectricCar IS-A Vehicle
class ElectricCar extends Vehicle { }

// Composition: Car HAS-A Engine
class Car {
    private Engine engine;
    private Transmission transmission;
    
    public void changeEngine(Engine newEngine) {
        this.engine = newEngine; // Runtime flexibility
    }
}
```

### **Q6: What are SOLID principles? Explain with examples.**

**Answer:**

**S - Single Responsibility Principle:**
```java
// Bad: Class has multiple responsibilities
class Vehicle {
    void start() { }
    void saveToDatabase() { } // Database responsibility
    void sendEmail() { }      // Email responsibility
}

// Good: Separate responsibilities
class Vehicle {
    void start() { }
}
class VehicleRepository {
    void save(Vehicle vehicle) { }
}
class NotificationService {
    void sendEmail(String message) { }
}
```

**O - Open/Closed Principle:**
```java
// Open for extension, closed for modification
abstract class Shape {
    abstract double calculateArea();
}

class Rectangle extends Shape {
    double calculateArea() { return width * height; }
}

class Circle extends Shape {
    double calculateArea() { return Math.PI * radius * radius; }
}

// Adding new shape doesn't modify existing code
class Triangle extends Shape {
    double calculateArea() { return 0.5 * base * height; }
}
```

**L - Liskov Substitution Principle:**
```java
// Subclasses should be substitutable for their base classes
AbstractVehicle vehicle = new Car(); // OK
vehicle.accelerate(60); // Works correctly

AbstractVehicle vehicle2 = new Airplane(); // OK
vehicle2.accelerate(60); // Works correctly
```

**I - Interface Segregation Principle:**
```java
// Bad: Fat interface forces unnecessary implementation
interface VehicleOperations {
    void drive();
    void fly();    // Not all vehicles can fly
    void swim();   // Not all vehicles can swim
}

// Good: Segregated interfaces
interface Drivable { void drive(); }
interface Flyable { void fly(); }
interface Swimmable { void swim(); }

class Car implements Drivable { } // Only implements what it needs
class Airplane implements Drivable, Flyable { }
class Boat implements Drivable, Swimmable { }
```

**D - Dependency Inversion Principle:**
```java
// Bad: High-level module depends on low-level module
class Car {
    private GasolineEngine engine; // Tight coupling
    
    public Car() {
        this.engine = new GasolineEngine(); // Concrete dependency
    }
}

// Good: Depend on abstractions
class Car {
    private Engine engine; // Abstract dependency
    
    public Car(Engine engine) { // Dependency injection
        this.engine = engine;
    }
}

interface Engine {
    void start();
}

class GasolineEngine implements Engine { }
class ElectricEngine implements Engine { }
```

### **Q7: What is Method Overloading vs Method Overriding?**

**Answer:**

**Method Overloading (Compile-time Polymorphism):**
- Same method name, different parameters
- Resolved at compile time
- Within same class

```java
class Calculator {
    public int add(int a, int b) { return a + b; }
    public double add(double a, double b) { return a + b; }
    public int add(int a, int b, int c) { return a + b + c; }
}
```

**Method Overriding (Runtime Polymorphism):**
- Same method signature in parent and child
- Resolved at runtime
- Across inheritance hierarchy

```java
abstract class Vehicle {
    public abstract void accelerate(double speed);
}

class Car extends Vehicle {
    @Override
    public void accelerate(double speed) {
        // Car-specific implementation
    }
}

class Airplane extends Vehicle {
    @Override
    public void accelerate(double speed) {
        // Airplane-specific implementation
    }
}
```

### **Q8: What are Access Modifiers? Explain their scope.**

**Answer:**

| Modifier | Same Class | Same Package | Subclass | Different Package |
|----------|------------|--------------|----------|-------------------|
| private | ✓ | ✗ | ✗ | ✗ |
| default/package | ✓ | ✓ | ✗ | ✗ |
| protected | ✓ | ✓ | ✓ | ✗ |
| public | ✓ | ✓ | ✓ | ✓ |

```java
public class Vehicle {
    private String engineNumber;      // Only within Vehicle class
    protected String chassisNumber;   // Vehicle and its subclasses
    String model;                     // Same package
    public String brand;              // Everywhere
    
    private void internalDiagnostic() { } // Only Vehicle class
    protected void performMaintenance() { } // Subclasses can access
    void packageMethod() { }              // Same package
    public void start() { }               // Public access
}
```

### **Q9: What is the difference between Association, Aggregation, and Composition?**

**Answer:**

**Association**: "Uses-A" relationship, loose coupling
```java
class Driver {
    void drive(Car car) { } // Driver uses Car
}
```

**Aggregation**: "Has-A" relationship, weak ownership
```java
class Department {
    private List<Employee> employees; // Department has Employees
    // Employees can exist without Department
}
```

**Composition**: "Part-Of" relationship, strong ownership
```java
class Car {
    private Engine engine; // Engine is part of Car
    // Engine cannot exist without Car
    
    public Car() {
        this.engine = new Engine(); // Engine created with Car
    }
}
```

### **Q10: What is a Static member? Explain with examples.**

**Answer:**
Static members belong to the class rather than instances. Shared across all objects.

```java
public class Vehicle {
    private static int totalVehicles = 0;    // Class variable
    private static final double PI = 3.14159; // Class constant
    
    private String brand; // Instance variable
    
    public Vehicle(String brand) {
        this.brand = brand;
        totalVehicles++; // Increment class counter
    }
    
    public static int getTotalVehicles() { // Static method
        return totalVehicles;
        // Cannot access 'brand' here - it's instance variable
    }
    
    public static void resetCounter() {
        totalVehicles = 0;
    }
    
    static { // Static block - runs once when class is loaded
        System.out.println("Vehicle class loaded");
        totalVehicles = 0;
    }
}

// Usage
Vehicle car1 = new Vehicle("Toyota");
Vehicle car2 = new Vehicle("Honda");
System.out.println(Vehicle.getTotalVehicles()); // 2
Vehicle.resetCounter(); // Called on class, not instance
```

---

## Language-Specific Implementations

### **Java**
```java
// Strengths: Strong typing, interfaces, abstract classes
public abstract class Vehicle implements Drivable, Maintainable {
    protected final String brand; // Immutable after construction
    
    public Vehicle(String brand) {
        this.brand = Objects.requireNonNull(brand);
    }
    
    @Override
    public final boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Vehicle)) return false;
        Vehicle vehicle = (Vehicle) obj;
        return Objects.equals(brand, vehicle.brand);
    }
}
```

### **C#**
```csharp
// Strengths: Properties, events, generics
public abstract class Vehicle : IDrivable, IMaintainable
{
    public string Brand { get; protected set; }
    public event EventHandler<SpeedChangedEventArgs> SpeedChanged;
    
    protected virtual void OnSpeedChanged(double newSpeed)
    {
        SpeedChanged?.Invoke(this, new SpeedChangedEventArgs(newSpeed));
    }
    
    public abstract void Accelerate(double speed);
}

public class Car : Vehicle
{
    public override void Accelerate(double speed)
    {
        CurrentSpeed = Math.Min(speed, MaxSpeed);
        OnSpeedChanged(CurrentSpeed); // Trigger event
    }
}
```

### **PHP**
```php
// Strengths: Traits, flexible typing, magic methods
abstract class Vehicle implements Drivable, Maintainable
{
    use TimestampTrait, LoggingTrait {
        TimestampTrait::touch insteadof LoggingTrait;
        LoggingTrait::touch as logTouch;
    }
    
    protected string $brand;
    
    public function __construct(string $brand)
    {
        $this->brand = $brand;
        $this->setTimestamps();
    }
    
    public function __toString(): string
    {
        return "{$this->brand} {$this->getVehicleType()}";
    }
    
    public function __call(string $method, array $args)
    {
        if (str_starts_with($method, 'get')) {
            $property = lcfirst(substr($method, 3));
            return $this->$property ?? null;
        }
        throw new BadMethodCallException("Method {$method} not found");
    }
}
```

### **Python**
```python
# Strengths: Multiple inheritance, duck typing, properties
from abc import ABC, abstractmethod
from typing import Protocol

class Drivable(Protocol):
    def accelerate(self, speed: float) -> None: ...
    def brake(self) -> None: ...

class Vehicle(ABC):
    def __init__(self, brand: str, model: str):
        self._brand = brand
        self._model = model
        self._speed = 0.0
    
    @property
    def brand(self) -> str:
        return self._brand
    
    @property
    def speed(self) -> float:
        return self._speed
    
    @speed.setter
    def speed(self, value: float) -> None:
        if value >= 0:
            self._speed = value
    
    @abstractmethod
    def accelerate(self, speed: float) -> None:
        pass
    
    def __str__(self) -> str:
        return f"{self._brand} {self._model}"
    
    def __repr__(self) -> str:
        return f"Vehicle('{self._brand}', '{self._model}')"
```

---

## Best Practices

### **1. Design Principles**
- **Favor composition over inheritance**
- **Program to interfaces, not implementations**
- **Follow SOLID principles**
- **Use meaningful names**
- **Keep classes focused and cohesive**

### **2. Common Mistakes to Avoid**
```java
// Bad: God class with too many responsibilities
class Vehicle {
    void start() { }
    void saveToDatabase() { }
    void sendNotification() { }
    void calculateTax() { }
    void generateReport() { }
}

// Good: Focused classes
class Vehicle {
    void start() { }
    void stop() { }
}

class VehicleRepository {
    void save(Vehicle vehicle) { }
}

class TaxCalculator {
    double calculateTax(Vehicle vehicle) { }
}
```

### **3. Performance Considerations**
- **Lazy initialization** for expensive objects
- **Object pooling** for frequently created objects
- **Immutable objects** for thread safety
- **Proper equals() and hashCode()** implementation

```java
public class Vehicle {
    private Engine engine; // Lazy initialization
    
    public Engine getEngine() {
        if (engine == null) {
            engine = new Engine(); // Create only when needed
        }
        return engine;
    }
}
```

### **4. Testing Considerations**
```java
// Testable design with dependency injection
public class VehicleService {
    private final VehicleRepository repository;
    private final NotificationService notificationService;
    
    public VehicleService(VehicleRepository repository, 
                         NotificationService notificationService) {
        this.repository = repository;
        this.notificationService = notificationService;
    }
    
    public void processVehicle(Vehicle vehicle) {
        repository.save(vehicle);
        notificationService.notify("Vehicle processed: " + vehicle.getBrand());
    }
}

// Easy to mock dependencies in tests
@Test
public void testProcessVehicle() {
    VehicleRepository mockRepo = mock(VehicleRepository.class);
    NotificationService mockNotification = mock(NotificationService.class);
    VehicleService service = new VehicleService(mockRepo, mockNotification);
    
    Vehicle vehicle = new Car("Toyota", "Camry", 2023, "Automatic");
    service.processVehicle(vehicle);
    
    verify(mockRepo).save(vehicle);
    verify(mockNotification).notify(anyString());
}
```

---

## Summary

This comprehensive guide demonstrates that OOP concepts are universal across programming languages, though their implementation may vary. The key takeaways:

1. **Encapsulation** protects data and provides controlled access
2. **Inheritance** enables code reuse and establishes "IS-A" relationships
3. **Polymorphism** allows uniform treatment of different object types
4. **Abstraction** hides complexity and focuses on essential features
5. **Interfaces** define contracts for unrelated classes
6. **Abstract classes** provide partial implementation with enforced structure
7. **Traits** (where available) enable code reuse without inheritance constraints

Understanding these concepts and their proper application is crucial for writing maintainable, scalable, and robust object-oriented code in any language.
